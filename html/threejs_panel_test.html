<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>ThreeJS Panel Test</title>
    <script src="../js/core-functionality.js"></script>
</head>

<body style="margin: 0; padding: 0; height: 3000px;">

<canvas id="c" width="1920px" height="1080px" style="position: fixed; width: 100%; height: 100%;"></canvas>

<script type="module">

    import * as THREE from "../js/threejs/three.module.js"

    import {FBXLoader} from "../js/threejs/jsm/loaders/FBXLoader.js";
    import {EffectComposer} from "../js/threejs/jsm/postprocessing/EffectComposer.js";
    import {ClearPass} from "../js/threejs/jsm/postprocessing/ClearPass.js";
    import {ClearMaskPass, MaskPass} from "../js/threejs/jsm/postprocessing/MaskPass.js";
    import {RenderPass} from "../js/threejs/jsm/postprocessing/RenderPass.js";
    import {ShaderPass} from "../js/threejs/jsm/postprocessing/ShaderPass.js";
    import {CopyShader} from "../js/threejs/jsm/shaders/CopyShader.js";

    let canvas = document.getElementById("c");

    let canvasWidth = canvas.clientWidth;
    let canvasHeight = canvas.clientHeight;

    let renderer = new THREE.WebGLRenderer({canvas: canvas, antialias: true});
    renderer.setClearColor(new THREE.Color(1, .5, 1))

    let renderTarget = new THREE.WebGLRenderTarget(canvasWidth, canvasHeight,
        {
            minFilter: THREE.LinearFilter,
            magFilter: THREE.LinearFilter,
            format: THREE.RGBFormat,
            stencilBuffer: true
    });

    let composer = new EffectComposer(renderer, renderTarget);

    let cameraScrollStart = 1.25 * (canvasWidth/canvasHeight) * (3786/1980) / 2;
    let cameraScrollEnd = -1.25 * (canvasWidth/canvasHeight) * (3786/1980) / 2;
    let camera = new THREE.OrthographicCamera(-1, 1, 1, -1, .0, 1000);
    camera.aspect = canvasWidth / canvasHeight;

    camera.position.y = cameraScrollStart;

    let scene = new THREE.Scene();
    let maskScene = new THREE.Scene();
    let underScene = new THREE.Scene();

    let clearPass = new ClearPass();
    let clearMaskPass = new ClearMaskPass();

    let scenePass = new RenderPass(scene, camera);
    let maskPass = new MaskPass(maskScene, camera);

    let underPass = new RenderPass(underScene, camera);
    underPass.clear = false;

    let maskSceneTest = new RenderPass(maskScene, camera);
    let outputPass = new ShaderPass(CopyShader);

    composer = new EffectComposer(renderer, renderTarget);
    composer.addPass(clearPass);
    composer.addPass(scenePass);
    composer.addPass(maskPass);
    composer.addPass(underPass);
    composer.addPass(clearMaskPass);
    composer.addPass(outputPass);

    let torus = new THREE.Mesh(new THREE.BoxGeometry(1,1,1), new THREE.MeshBasicMaterial({color: 0xFF0000}));
    torus.position.z = -100;
    underScene.add(torus);

    let textureLoader = new THREE.TextureLoader();
    let loader = new FBXLoader();

    let panelScaleX = .006;
    let panelScaleY = .006 * (canvasWidth/canvasHeight);


    function MakePanel(border, content, box = null){
        return {border: border, content: content, box: box};
    }

    let top_m_tri;
    loader.load("../models/panel_test/top_m_tri.fbx",
        function (object) {

            object.children[0].rotation.x = 0;
            object.scale.x = panelScaleX
            object.scale.y = panelScaleY;

            let border = object.clone();
            border.children[0].material = new THREE.MeshBasicMaterial({alphaTest: .5, map: textureLoader.load("../imgs/panel_test/top_m_tri/top_m_tri_border.png")});

            let grid = object.clone();
            grid.children[0].material = new THREE.MeshBasicMaterial({alphaTest: .5, map: textureLoader.load("../imgs/uv_test_grid.png")});
            grid.position.z = -1;

            let box = new THREE.BoxHelper(border, 0xff0000);
            top_m_tri = MakePanel(border, {grid: grid}, box);

            scene.add(border);
            scene.add(grid);
        }
    );

    let top_l_tri;
    loader.load("../models/panel_test/top_l_tri.fbx",
        function (object) {

            object.children[0].rotation.x = 0;
            object.scale.x = panelScaleX
            object.scale.y = panelScaleY;

            let border = object.clone();
            border.children[0].material = new THREE.MeshBasicMaterial({alphaTest: .5, map: textureLoader.load("../imgs/panel_test/top_l_tri/top_l_tri_border.png")});

            let grid = object.clone();
            grid.children[0].material = new THREE.MeshBasicMaterial({alphaTest: .5, map: textureLoader.load("../imgs/uv_test_grid.png")});
            grid.position.z = -1;

            let box = new THREE.BoxHelper(border, 0xff0000);
            top_l_tri = MakePanel(border, {grid: grid}, box);

            scene.add(border);
            scene.add(grid);
        }
    );

    let top_r_tri;
    loader.load("../models/panel_test/top_r_tri.fbx",
        function (object) {

            object.children[0].rotation.x = 0;
            object.scale.x = panelScaleX;
            object.scale.y = panelScaleY;

            let border = object.clone();
            border.children[0].material = new THREE.MeshBasicMaterial({alphaTest: .5, map: textureLoader.load("../imgs/panel_test/top_r_tri/top_r_tri_border.png")});

            let grid = object.clone();
            grid.children[0].material = new THREE.MeshBasicMaterial({alphaTest: .5, map: textureLoader.load("../imgs/uv_test_grid.png")});
            grid.position.z = -1;

            let box = new THREE.BoxHelper(border, 0xff0000);
            top_r_tri = MakePanel(border, {grid: grid}, box);

            scene.add(border);
            scene.add(grid);
        }
    );

    let bot_m_tri;
    loader.load("../models/panel_test/bot_m_tri.fbx",
        function (object) {

            object.children[0].rotation.x = 0;
            object.scale.x = panelScaleX;
            object.scale.y = panelScaleY;

            let border = object.clone();
            border.children[0].material = new THREE.MeshBasicMaterial({alphaTest: 0.5, map: textureLoader.load("../imgs/panel_test/bot_m_tri/bot_m_tri_border.png")});

            let grid = object.clone();
            grid.children[0].material = new THREE.MeshBasicMaterial({alphaTest: .5, map: textureLoader.load("../imgs/uv_test_grid.png")});
            grid.position.z = -1;

            let box = new THREE.BoxHelper(border, 0xff0000);
            bot_m_tri = MakePanel(border, {grid: grid}, box);

            scene.add(border);
            scene.add(grid);
        }
    );

    let bot_l_tri;
    loader.load("../models/panel_test/bot_l_tri.fbx",
        function (object) {

            object.children[0].rotation.x = 0;
            object.scale.x = panelScaleX;
            object.scale.y = panelScaleY;

            let border = object.clone();
            border.children[0].material = new THREE.MeshBasicMaterial({alphaTest: 0.5, map: textureLoader.load("../imgs/panel_test/bot_l_tri/bot_l_tri_border.png")});

            let grid = object.clone();
            grid.children[0].material = new THREE.MeshBasicMaterial({alphaTest: .5, map: textureLoader.load("../imgs/uv_test_grid.png")});
            grid.position.z = -1;

            let box = new THREE.BoxHelper(border, 0xff0000);
            bot_l_tri = MakePanel(border, {grid: grid}, box);

            scene.add(border);
            scene.add(grid);
        }
    );

    let bot_r_tri;
    loader.load("../models/panel_test/bot_r_tri.fbx",
        function (object) {

            object.children[0].rotation.x = 0;
            object.scale.x = panelScaleX;
            object.scale.y = panelScaleY;

            let border = object.clone();
            border.children[0].material = new THREE.MeshBasicMaterial({alphaTest: 0.5, map: textureLoader.load("../imgs/panel_test/bot_r_tri/bot_r_tri_border.png")});

            let grid = object.clone();
            grid.children[0].material = new THREE.MeshBasicMaterial({alphaTest: .5, map: textureLoader.load("../imgs/uv_test_grid.png")});
            grid.position.z = -1;

            let box = new THREE.BoxHelper(border, 0xff0000);
            bot_r_tri = MakePanel(border, {grid: grid}, box);

            scene.add(border);
            scene.add(grid);
        }
    );

    let top_rec;
    loader.load("../models/panel_test/top_rec.fbx",
        function (object) {

            object.children[0].rotation.x = 0;
            object.scale.x = panelScaleX;
            object.scale.y = panelScaleY;

            let border = object.clone();
            border.children[0].material = new THREE.MeshBasicMaterial({alphaTest: 0.5, map: textureLoader.load("../imgs/panel_test/top_rec/top_rec_border.png")});

            // let grid = object.clone();
            // grid.children[0].material = new THREE.MeshBasicMaterial({alphaTest: .5, map: textureLoader.load("../imgs/uv_test_grid.png")});
            // grid.position.z = -1;

            let box = new THREE.BoxHelper(border, 0xff0000);
            top_rec = MakePanel(border, {}, box);

            scene.add(border);
            // scene.add(grid);

            maskScene.add(object);
        }
    );

    let mid_rec;
    loader.load("../models/panel_test/mid_rec.fbx",
        function (object) {

            object.children[0].rotation.x = 0;

            object.scale.x = panelScaleX;
            object.scale.y = panelScaleY;

            let border = object.clone();
            border.children[0].material = new THREE.MeshBasicMaterial({alphaTest: 0.5, map: textureLoader.load("../imgs/panel_test/mid_rec/mid_rec_border.png")});

            // let grid = object.clone();
            // grid.children[0].material = new THREE.MeshBasicMaterial({alphaTest: .5, map: textureLoader.load("../imgs/uv_test_grid.png")});
            // grid.position.z = -1;

            let box = new THREE.BoxHelper(border, 0xff0000);
            mid_rec = MakePanel(border, {}, box);


            scene.add(border);
            // scene.add(grid);

            maskScene.add(object);
        }
    );

    let bot_rec;
    loader.load("../models/panel_test/bot_rec.fbx",
        function (object) {

            object.children[0].rotation.x = 0;
            object.scale.x = panelScaleX;
            object.scale.y = panelScaleY;

            let border = object.clone();
            border.children[0].material = new THREE.MeshBasicMaterial({alphaTest: 0.5, map: textureLoader.load("../imgs/panel_test/bot_rec/bot_rec_border.png")});

            let grid = object.clone();
            grid.children[0].material = new THREE.MeshBasicMaterial({alphaTest:0.5, map: textureLoader.load("../imgs/uv_test_grid.png")});
            grid.position.z = -1;


            let box = new THREE.BoxHelper(border, 0xff0000);
            bot_rec = MakePanel(border, {}, box);

            scene.add(border);

            maskScene.add(object);

            // scene.add(grid);
        }
    );

    let previousTime = 0;

    function render(time) {
        time *= .001;
        let deltaTime = time - previousTime;
        previousTime = time;

        torus.rotation.x += deltaTime;
        torus.rotation.y += deltaTime;
        torus.rotation.z += deltaTime;

        renderer.clear();
        composer.render(performance.now() * 0.001 + 6000);

        // renderer.render(scene, camera);

        requestAnimationFrame(render);
    }

    function BoxIsOnScreen(box, camera){

        let cameraMin = (camera.position.y - 1);
        let cameraMax = (camera.position.y + 1);

        let mid_rec_min = box.geometry.boundingBox.min.y;
        let mid_rec_max = box.geometry.boundingBox.max.y;

        return (mid_rec_min >= cameraMin && mid_rec_min <= cameraMax) ||
               (mid_rec_max >= cameraMin && mid_rec_max <= cameraMax);


    }

    function BoxOnScreenLerpPosition(box, camera){

        let mid_rec_min = box.geometry.boundingBox.min.y;
        let mid_rec_max = box.geometry.boundingBox.max.y;

        let mid_rec_normal_position = (camera.position.y - (mid_rec_max+1))/((mid_rec_min-1)-(mid_rec_max+1));

        return mid_rec_normal_position;

    }

    function OnScroll(event){
        let scrollPos = WindowScrollNormalPosition();

        camera.position.y = lerp(cameraScrollStart, cameraScrollEnd, scrollPos);
        torus.position.y = camera.position.y;
        console.log(torus);
        console.log(camera);


        // if(mid_rec){
        //
        //     //TODO: bounding box only needs to be computed when scale changes (in screen resize)
        //     mid_rec.box.geometry.computeBoundingBox();
        //
        //
        //     let mid_rec_normal_position = BoxOnScreenLerpPosition(mid_rec.box, camera);
        //
        //
        //     mid_rec.content.grid.children[0].material.map.offset.y = lerp(0,
        //         -.1,
        //         mid_rec_normal_position);
        //
        //
        //     if(BoxIsOnScreen(mid_rec.box, camera)){
        //         console.log("mid rec is on screen");
        //     }else{
        //         console.log("mid rec is not on screen");
        //     }
        //
        //     console.log("__________________");
        // }
        //
        // if(bot_rec){
        //
        //     let ratio = canvasWidth/canvasHeight;
        //     bot_rec.content.grid.children[0].material.map.offset.y = lerp(.1 * ratio,
        //                                                                    0,
        //                                                                    scrollPos);
        // }
    }

    document.addEventListener("scroll", OnScroll);

    window.addEventListener("resize", function (event) {


        canvasWidth = canvas.clientWidth;
        canvasHeight = canvas.clientHeight;

        // spriteHeight = 2 * (canvasWidth / canvasHeight) * (3000 / 1080);

        camera.aspect = canvasWidth / canvasHeight;
        camera.updateProjectionMatrix();

        renderer.setSize(canvasWidth, canvasHeight, false);

        panelScaleY = .006 * (canvasWidth/canvasHeight);

        //TODO: update scale
        top_m_tri.border.scale.y = top_m_tri.content.grid.scale.y =
            top_l_tri.border.scale.y = top_l_tri.content.grid.scale.y =
            top_r_tri.border.scale.y = top_r_tri.content.grid.scale.y =
            bot_m_tri.border.scale.y = bot_m_tri.content.grid.scale.y =
            bot_l_tri.border.scale.y = bot_l_tri.content.grid.scale.y =
            bot_r_tri.border.scale.y = bot_r_tri.content.grid.scale.y =
            top_rec.border.scale.y = top_rec.content.grid.scale.y =
            mid_rec.border.scale.y = mid_rec.content.grid.scale.y =
            bot_rec.border.scale.y = bot_rec.content.grid.scale.y = panelScaleY;
        // top_m_tri.scale.y = top_l_tri.scale.y = top_r_tri.scale.y =
        //                     bot_m_tri.scale.y = bot_l_tri.scale.y =
        //                     bot_r_tri.scale.y = top_rec.scale.y =
        //                     mid_rec.scale.y = bot_rec.scale.y = content.scale.y = panelScaleY;


        cameraScrollStart = 1.25 * (canvasWidth/canvasHeight) * (3786/1980) / 2;
        cameraScrollEnd = -1.25 * (canvasWidth/canvasHeight) * (3786/1980) / 2;
        OnScroll();
        // top_m_tri.children[0].geometry.computeBoundingBox();
        // bot_rec.children[0].geometry.computeBoundingBox();
        //
        // cameraScrollStart = top_m_tri.children[0].geometry.boundingBox.max.y;
        // cameraScrollEnd = bot_rec.children[0].geometry.boundingBox.min.y;
        OnScroll();

        // renderer.setPixelRatio(window.devicePixelRatio);
        // renderer.setSize(canvasWidth, canvasHeight);

        // let scrollPos = WindowScrollNormalPosition();
        // let screenPos = lerp((-spriteHeight / 2) + 1, (spriteHeight / 2) - 1, scrollPos);

        // for (let i = 0; i < sprites.length; i++) {
        //     sprites[i].scale.set(2, spriteHeight, 1);
        //     sprites[i].position.y = screenPos;
        // }

    }, true);

    requestAnimationFrame(render);


</script>
</body>
</html>